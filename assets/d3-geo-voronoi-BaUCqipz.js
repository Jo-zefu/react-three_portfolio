import{g as z,a as R,b as q,c as w}from"./d3-geo-IBeQgcAP.js";import{D as A}from"./d3-delaunay-Ba8_sCpG.js";import{e as P}from"./d3-array-DwlNfeyV.js";const M=Math.PI,S=M/2,b=180/M,x=M/180,L=Math.atan2,C=Math.cos,I=Math.max,V=Math.min,D=Math.sin,B=Math.sign||function(t){return t>0?1:t<0?-1:0},$=Math.sqrt;function G(t){return t>1?S:t<-1?-S:Math.asin(t)}function k(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]}function g(t,e){return[t[1]*e[2]-t[2]*e[1],t[2]*e[0]-t[0]*e[2],t[0]*e[1]-t[1]*e[0]]}function _(t,e){return[t[0]+e[0],t[1]+e[1],t[2]+e[2]]}function v(t){var e=$(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);return[t[0]/e,t[1]/e,t[2]/e]}function E(t){return[L(t[1],t[0])*b,G(I(-1,V(1,t[2])))*b]}function p(t){const e=t[0]*x,n=t[1]*x,r=C(n);return[r*C(e),r*D(e),D(n)]}function F(t){return t=t.map(e=>p(e)),k(t[0],g(t[2],t[1]))}function H(t){const e=K(t),n=Q(e),r=O(n,t),o=U(n,t.length),i=J(o,t),a=T(n,t),{polygons:u,centers:s}=W(a,n,t),c=X(u),l=Z(n,t),f=Y(r,n);return{delaunay:e,edges:r,triangles:n,centers:s,neighbors:o,polygons:u,mesh:c,hull:l,urquhart:f,find:i}}function J(t,e){function n(r,o){let i=r[0]-o[0],a=r[1]-o[1],u=r[2]-o[2];return i*i+a*a+u*u}return function(o,i,a){a===void 0&&(a=0);let u,s,c=a;const l=p([o,i]);do u=a,a=null,s=n(l,p(e[u])),t[u].forEach(f=>{let h=n(l,p(e[f]));if(h<s){s=h,a=f,c=f;return}});while(a!==null);return c}}function K(t){if(t.length<2)return{};let e=0;for(;isNaN(t[e][0]+t[e][1])&&e++<t.length;);const n=z(t[e]),r=R().translate([0,0]).scale(1).rotate(n.invert([180,0]));t=t.map(r);const o=[];let i=1;for(let f=0,h=t.length;f<h;f++){let d=t[f][0]**2+t[f][1]**2;!isFinite(d)||d>1e32?o.push(f):d>i&&(i=d)}const a=1e6*$(i);o.forEach(f=>t[f]=[a,0]),t.push([0,a]),t.push([-a,0]),t.push([0,-a]);const u=A.from(t);u.projection=r;const{triangles:s,halfedges:c,inedges:l}=u;for(let f=0,h=c.length;f<h;f++)if(c[f]<0){const d=f%3==2?f-2:f+1,j=f%3==0?f+2:f-1,m=c[d],y=c[j];c[m]=y,c[y]=m,c[d]=c[j]=-1,s[f]=s[d]=s[j]=e,l[s[m]]=m%3==0?m+2:m-1,l[s[y]]=y%3==0?y+2:y-1,f+=2-f%3}else s[f]>t.length-3-1&&(s[f]=e);return u}function O(t,e){const n=new Set;return e.length===2?[[0,1]]:(t.forEach(r=>{if(r[0]!==r[1]&&!(F(r.map(o=>e[o]))<0))for(let o=0,i;o<3;o++)i=(o+1)%3,n.add(P([r[o],r[i]]).join("-"))}),Array.from(n,r=>r.split("-").map(Number)))}function Q(t){const{triangles:e}=t;if(!e)return[];const n=[];for(let r=0,o=e.length/3;r<o;r++){const i=e[3*r],a=e[3*r+1],u=e[3*r+2];i!==a&&a!==u&&n.push([i,u,a])}return n}function T(t,e){return t.map(n=>{const r=n.map(i=>e[i]).map(p),o=_(_(g(r[1],r[0]),g(r[2],r[1])),g(r[0],r[2]));return E(v(o))})}function U(t,e){const n=[];return t.forEach(r=>{for(let o=0;o<3;o++){const i=r[o],a=r[(o+1)%3];n[i]=n[i]||[],n[i].push(a)}}),t.length===0&&(e===2?(n[0]=[1],n[1]=[0]):e===1&&(n[0]=[])),n}function W(t,e,n){const r=[],o=t.slice();if(e.length===0){if(n.length<2)return{polygons:r,centers:o};if(n.length===2){const u=p(n[0]),s=p(n[1]),c=v(_(u,s)),l=v(g(u,s)),f=g(c,l),h=[c,g(c,f),g(g(c,f),f),g(g(g(c,f),f),f)].map(E).map(a);return r.push(h),r.push(h.slice().reverse()),{polygons:r,centers:o}}}e.forEach((u,s)=>{for(let c=0;c<3;c++){const l=u[c],f=u[(c+1)%3],h=u[(c+2)%3];r[l]=r[l]||[],r[l].push([f,h,s,[l,f,h]])}});const i=r.map(u=>{const s=[u[0][2]];let c=u[0][1];for(let l=1;l<u.length;l++)for(let f=0;f<u.length;f++)if(u[f][0]==c){c=u[f][1],s.push(u[f][2]);break}if(s.length>2)return s;if(s.length==2){const l=N(n[u[0][3][0]],n[u[0][3][1]],o[s[0]]),f=N(n[u[0][3][2]],n[u[0][3][0]],o[s[0]]),h=a(l),d=a(f);return[s[0],d,s[1],h]}});function a(u){let s=-1;return o.slice(e.length,1/0).forEach((c,l)=>{c[0]===u[0]&&c[1]===u[1]&&(s=l+e.length)}),s<0&&(s=o.length,o.push(u)),s}return{polygons:i,centers:o}}function N(t,e,n){t=p(t),e=p(e),n=p(n);const r=B(k(g(e,t),n));return E(v(_(t,e)).map(o=>r*o))}function X(t){const e=[];return t.forEach(n=>{if(!n)return;let r=n[n.length-1];for(let o of n)o>r&&e.push([r,o]),r=o}),e}function Y(t,e){return function(n){const r=new Map,o=new Map;return t.forEach((i,a)=>{const u=i.join("-");r.set(u,n[a]),o.set(u,!0)}),e.forEach(i=>{let a=0,u=-1;for(let s=0;s<3;s++){let c=P([i[s],i[(s+1)%3]]).join("-");r.get(c)>a&&(a=r.get(c),u=c)}o.set(u,!1)}),t.map(i=>o.get(i.join("-")))}}function Z(t,e){const n=new Set,r=[];t.map(u=>{if(!(F(u.map(s=>e[s>e.length?0:s]))>1e-12))for(let s=0;s<3;s++){let c=[u[s],u[(s+1)%3]],l=`${c[0]}-${c[1]}`;n.has(l)?n.delete(l):n.add(`${c[1]}-${c[0]}`)}});const o=new Map;let i;if(n.forEach(u=>{u=u.split("-").map(Number),o.set(u[0],u[1]),i=u[0]}),i===void 0)return r;let a=i;do{r.push(a);let u=o.get(a);o.set(a,-1),a=u}while(a>-1&&a!==i);return r}function re(t){const e=function(n){if(e.delaunay=null,e._data=n,typeof e._data=="object"&&e._data.type==="FeatureCollection"&&(e._data=e._data.features),typeof e._data=="object"){const r=e._data.map(o=>[e._vx(o),e._vy(o),o]).filter(o=>isFinite(o[0]+o[1]));e.points=r.map(o=>[o[0],o[1]]),e.valid=r.map(o=>o[2]),e.delaunay=H(e.points)}return e};return e._vx=function(n){if(typeof n=="object"&&"type"in n)return q(n)[0];if(0 in n)return n[0]},e._vy=function(n){if(typeof n=="object"&&"type"in n)return q(n)[1];if(1 in n)return n[1]},e.x=function(n){return n?(e._vx=n,e):e._vx},e.y=function(n){return n?(e._vy=n,e):e._vy},e.polygons=function(n){if(n!==void 0&&e(n),!e.delaunay)return!1;const r={type:"FeatureCollection",features:[]};return e.valid.length===0||(e.delaunay.polygons.forEach((o,i)=>r.features.push({type:"Feature",geometry:o?{type:"Polygon",coordinates:[[...o,o[0]].map(a=>e.delaunay.centers[a])]}:null,properties:{site:e.valid[i],sitecoordinates:e.points[i],neighbours:e.delaunay.neighbors[i]}})),e.valid.length===1&&r.features.push({type:"Feature",geometry:{type:"Sphere"},properties:{site:e.valid[0],sitecoordinates:e.points[0],neighbours:[]}})),r},e.triangles=function(n){return n!==void 0&&e(n),e.delaunay?{type:"FeatureCollection",features:e.delaunay.triangles.map((r,o)=>(r=r.map(i=>e.points[i]),r.center=e.delaunay.centers[o],r)).filter(r=>F(r)>0).map(r=>({type:"Feature",properties:{circumcenter:r.center},geometry:{type:"Polygon",coordinates:[[...r,r[0]]]}}))}:!1},e.links=function(n){if(n!==void 0&&e(n),!e.delaunay)return!1;const r=e.delaunay.edges.map(i=>w(e.points[i[0]],e.points[i[1]])),o=e.delaunay.urquhart(r);return{type:"FeatureCollection",features:e.delaunay.edges.map((i,a)=>({type:"Feature",properties:{source:e.valid[i[0]],target:e.valid[i[1]],length:r[a],urquhart:!!o[a]},geometry:{type:"LineString",coordinates:[e.points[i[0]],e.points[i[1]]]}}))}},e.mesh=function(n){return n!==void 0&&e(n),e.delaunay?{type:"MultiLineString",coordinates:e.delaunay.edges.map(r=>[e.points[r[0]],e.points[r[1]]])}:!1},e.cellMesh=function(n){if(n!==void 0&&e(n),!e.delaunay)return!1;const{centers:r,polygons:o}=e.delaunay,i=[];for(const a of o)if(a)for(let u=a.length,s=a[u-1],c=a[0],l=0;l<u;s=c,c=a[++l])c>s&&i.push([r[s],r[c]]);return{type:"MultiLineString",coordinates:i}},e._found=void 0,e.find=function(n,r,o){if(e._found=e.delaunay.find(n,r,e._found),!o||w([n,r],e.points[e._found])<o)return e._found},e.hull=function(n){n!==void 0&&e(n);const r=e.delaunay.hull,o=e.points;return r.length===0?null:{type:"Polygon",coordinates:[[...r.map(i=>o[i]),o[r[0]]]]}},e(t)}export{re as g};
